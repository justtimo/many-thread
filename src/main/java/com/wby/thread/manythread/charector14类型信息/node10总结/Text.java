package com.wby.thread.manythread.charector14类型信息.node10总结;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/7/8 20:48
 * @Description:    RTTI允许通过匿名基类的引用发现类型信息。初学者容易误用他，因为在学会使用多态调用方法之前，这么做也很有效。
 *  对有经验的人来说，很难让他们不把程序组织成一系列switch语句。
 *  你可以用RTTI做到这一点，但是这样在代码开发和维护过程中损失了多态机制的重要价值。
 *  面向对象编程的目的是让我们在凡事可以使用的地方都是用多态机制，只在必要时候使用RTTI。
 *
 *  然而使用多态机制的方法调用，要求我们拥有基类定义的控制权，因为在扩展程序的时候，可能会发现基类并未包含我们想要的方法。
 *  这样做不会破坏多态性以及程序的扩展能力，因为这样添加一个新的类并不需要在程序中搜索switch语句。但如果在程序主体中添加需要的新特性代码，
 *  就必须使用RTTI来检查你的特定类型
 *
 *  如果只是为了某个特定类的利益，而将某个特性放进基类里，这意味着从那个基类派生出的所有其他子类都带有这些可能无意义的东西。这会使得接口
 *  不清晰，因为我们必须覆盖由基类继承而来的所有抽象方法。
 *  例如我们想清洁管弦乐队中的口水，一种办法是在基类Instrument中放入clearSpitValve()方法，但这意味着打击乐器、弦乐器和电子乐器也需要
 *  清洁口水。
 *  这个例子中RTTI可以提供了一种更合理的解决方案。可以将clearSpitValve()置于特定类中，这个例子中就是Wind管乐器。
 *  同时，可能会发现还有更好的解决方法，就是将prepareInstrument()置于基类中
 *
 *  最后，RTTI有时能解决效率问题。也许你的程序中漂亮的使用了多态，但其中某个对象是以极端缺乏效率的方式达到这个目的。
 *  你可以挑出这个类，使用RTTI，并且为其编写一段特别的代码以提高效率。
 *  然而不要太早关注程序的效率问题，首先应该让程序运作起来，然后再考虑他的速度，如果要解决效率问题可以使用profiler
 *
 *  我们可以看到，反射允许更加动态的编程风格，因此他开创了编程的新世界。
 *  对有些人来说，反射的动态特性是一种困扰，对于已经习惯静态类型检查的安全性的人来说，你可以执行一些只能在运行时进行的检查，并用异常报告检查
 *  结果的行为，这本身就是一种错误的方向。
 *  有些人走的更远，他们生成引入运行时异常本身就是一种指示，说明应该避免这种代码。
 *  我发现这种意义的安全是一种错觉，因为总是有些事情是在运行时发生并抛出异常的，即使是在不包含任何try语句块或异常规格说明的程序中也是如此。
 *  因此，我认为一致的错误报告模型的存在使我们能够通过使用反射编写动态代码。
 *  当然，尽力编写能够进行静态检查的代码是值得的，只要你确实能够这么做。但是我相信动态代码是将java与其他诸如C++这样的语言区分开的重要工具之一。
 */
public class Text {
}
