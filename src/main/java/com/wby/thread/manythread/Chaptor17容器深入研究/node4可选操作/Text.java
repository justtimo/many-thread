package com.wby.thread.manythread.Chaptor17容器深入研究.node4可选操作;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/7/19 17:39
 * @Description: 执行各种不同的添加和移除的方法在Collection接口中都是 可选操作
 *  这意味着实现类并不需要为这些方法提供功能定义。
 *
 *  这是一种很不寻常的接口定义方式。正如看到的，接口是面向对象设计中的契约，他声明“无论你选择如何实现该接口，我保证你可以向该接口发送这些消息(这里使用属于“接口”
 *  来描述正式的interface关键字和“任何类或子类支持的方法”这一更通用的含义)。但是可选操作违反这个非常基本的原则，他声明调用某些方法将不会执行有意义的行为，
 *  相反，他们会抛出异常。这看齐像是编译期类型安全被抛弃了
 *
 *  事情不是那么糟糕。如果一个操作是可选的，编译器仍旧会严格要求你只能调用该接口中的方法。这与动态语言不同，动态语言可以在任何对象上调用任何方法，并且
 *  可以在运行时发现某个特定调用是否可以工作(14章中可以看到，这种类型的动态行为会显得非常强大)。另外，将Collection当做参数接受的大部分方法只会从该
 *  Collection中读取，而Collection的读取方法都不是可选的。
 *
 *  为什么你会将方法定义为可选的呢？那是因为这样做可以防止在设计中出现接口爆炸的情况。容器类库中的其他设计看起来总是为了描述每个主题的各种变体，而最终患上了令人困惑
 *  的接口过剩症。甚至这么做扔不能捕捉接口的各种特例，因为总是有人会发明新的接口。“未获支持的操作”这种方式可以实现java容器类库的一个重要目标：容器应该
 *  易学易用。未获支持的操作是一种特例，可以延迟到需要时再实现。但是，为了让这种方式能够工作：
 *      1. UnsupportedOperationException必须是一种罕见事件。即，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。
 *          在java容器类库中确实如此，因为你再99%的时间里面使用的容器类，如ArrayList、LinkedList、HashSet和HashMap，以及其他的具体实现，都
 *          支持所有的操作。这种设计留下了一个“后门”，如果你想创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的定义，那么
 *          他仍旧适合现有的类库。
 *      2. 如果一个操作是未获支持的，那么在实现接口的时候可能就会导致UnsupportedOperationException异常，而不是将产品程序交给客户以后才出现异常，
 *          这种情况是有道理的。毕竟，他表示编程上有错误：使用了不正确的接口实现。
 *
 *  值得注意的是，未获支持的操作只有在运行时才能探测到，因此他们表示动态类型检查。如果你以前使用的是像C++这样的静态类型语言，那么可能会觉得java也只是
 *  另一种静态类型语言，但是他还具有大量的动态类型机制，因此很难说他到底是哪一种类型的语言。一旦开始注意到这一点了，你就会看到java中动态类型检查的其他例子。
 */
public class Text {
}

