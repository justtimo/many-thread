package com.wby.thread.manythread.character21并发.node1并发的多面性.child1更快的执行;

/**
 * 速度问题初听起来很简单;如果你想要一个程序运行得更快，那么可以将其断开为多个片段，在单独的处理器上运行每个片段。并发是用于多处理器编程的基本工具。
 * 当前，Moore定律已经有些过时了（至少对于传统芯片是这样），速度提高是以多核处理器的形式而不是更快的芯片的形式出现的。
 * 为了使程序运行得更快，你必须学习如何利用这些额外的处理器，而这正是并发赋予你的能力。
 *
 * 如果你有一台多处理器的机器，那么就可以在这些处理器之间分布多个任务，从而可以极大地提高吞吐量。这是使用强有力的多处理器Web服务器的常见情况，在为每个请求分配一个线程的程序中，它可以将大量的用户请求分布到多个CPU上。
 *
 * 但是，并发通常是提高运行在单处理器上的程序的性能。
 *
 * 这听起来有些违背直觉。如果你仔细考虑一下就会发现，在单处理器上运行的并发程序开销确实应该比该程序的所有部分都顺序执行的开销大，因为其中增加了所谓上下文切换的代价（从一个任务切换到另一个任务）。
 * 表面上看，将程序的所有部分当作单个的任务运行好像是开销更小一点，并且可以节省上下文切换的代价。
 *
 * 使这个问题变得有些不同的是阻塞。如果程序中的某个任务因为该程序控制范围之外的某些条件（通常是I/O）而导致不能继续执行，那么我们就说这个任务或线程阻塞了。
 * 如果没有并发，则整个程序都将停止下来，直至外部条件发生变化。但是，如果使用并发来编写程序，那么当一个任务阻塞时，程序中的其他任务还可以继续执行，因此这个程序可以保持继续向前执行。
 * 事实上，从性能的角度看，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。
 *
 * 在单处理器系统中的性能提高的常见示例是事件驱动的编程。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。考虑这样一个程序，它因为将执行某些长期运行的操作，所以最终用户输入会被忽略，从而成为不可响应的程序。
 * 如果有一个"退出"按钮，那么你肯定不想在你写的每一段代码中都检查它的状态。因为这会产生非常尴尬的代码，而我们也无法保证程序员不会忘记这种检查。
 * 如果不使用并发，则产生可响应用户界面的唯一方式就是所有的任务都周期性地检查用户输入。通过创建单独的执行线程来响应用户的输入，即使这个线程在大多数时间里都是阻塞的，但是程序可以保证具有一定程度的可响应性。
 *
 * 程序需要连续执行它的操作，并且同时需要返回对用户界面的控制，以便使程序可以响应用户。但是传统的方法在连续执行其操作的同时，返回对程序其余部分的控制。
 * 事实上，这听起来就像是不可能之事，好像CPU必须同时位干两处—样、但是这完全是并发造成的一种错觉（在多处理器系统中，这就不只是一种幻觉了）。
 *
 * 实现并发最直接的方式是在操作系统级别使用进程。进程是）运行在它自己，的地址空间内的自包容的程序。多任务操作系统可以通过周期性地将CPU从一个进程切换到另一个进程，来实现同时运行多个进程（程序），
 * 尽管这使得每个进程看起来在其执行过程中都是歇歇停停。进程总是很吸引人，因为操作系统通常会将进程互相隔离开，因此它们不会彼此干涉，这使得用进程编程相对容易一些。
 * 与此相反的是，像Java所使用的这种并发系统会共享诸如内存和I/O这样的资源，因此编写多线程程序最基本的困难在于在协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。
 *
 * 这里有一个利用操作系统进程的简单示例。在编写本书时，我会有规律地创建本书当前状态的多个冗余备份副本。我会在本地目录中保存一个副本，在记忆棒上保存一个副本，在Zip盘上保存一个副本，
 * 还会在远程FTP站点上保存一个副本。为了自动化这个过程，我还编写了一个小程序 （用Python写的，但是其概念是相同的），它会把本书压缩成一个文件，其文件名中带有版本号，然后执行复制操作。
 * 最初，我会顺序执行所有的复制操作，在启动下一个复制操作之前先等待前一个操作的完成。但随后我意识到，每个复制操作会依存储介质I/O速度的不同而花费不同的时间。
 * 既然我在使用多任务操作系统，那就可以将每个复制操作当作单独的进程来启动，并让它们并行地运行，这样可以加速整个程序的执行速度。当一个进程受阻时，另一个进程可以继续向前运行。
 *
 * 这是并发的理想示例。每个任务都作为进程在其自己的地址空间中执行，因此任务之间根本不可能互相干涉。更重要的是，对进程来说，它们之间没有任何彼此通信的需要，因为它们都是完全独立的。
 * 操作系统会处理确保文件正确复制的所有细节，因此，不会有任何风险，你可以获得更快的程序，并且完全免费。
 *
 * 有些人走得更远，提倡将进程作为唯一合理的并发方式9，但遗憾的是，对进程通常会有数量和开销的限制，以避免它们在不同的并发系统之间的可应用性。
 *
 * 某些编程语言被设计为可以将并发任务彼此隔离，这些语言通常被称为函数型语言，其中每个函数调用都不会产生任何副作用（并因此而不能干涉其他函数），并因此可以当作独立的任务来驱动。
 * Erlang就是这样的语言，它包含针对任务之间彼此通信的安全机制。如果你发现程序中某个部分必须大量使用并发，并且你在试图构建这个部分时碰到了过多的问题，那么你可以考虑使用像Erlang这类专门的并发语言来创建这个部分。
 *
 * Java采取了更加传统的方式，在顺序型语言的基础上提供对线程的支持9。与在多任务操作系统中分叉外部进程不同，线程机制是在由执行程序表示的单一进程中创建任务。
 * 这种方式产生的一个好处是操作系统的透明性，这对Java而言，是一个重要的设计目标。例如，在OSX之前的Macintosh操作系统版本（Java第一个版本的一个非常重要的目标系统）不支持多任务，
 * 因此，除非在Java中添加多线程机制，否则任何并发的Java程序都无法移植到Macintosh和类似的平台之上，这样就会打破"编写一次，到处运行"的要求。
 *
 * e 例如，Eric Raymond在《The Artof UNIX Programming》（Addison-Wesley，2004）中提出了这种极端情况。
 * 可能有人会有异议，认为将并发绑定到顺序型语言上是一种糟糕的方式，但是你必须得出自己的结论。
 * ③ 这个要求从来都没有完全实现过，Sun也不再大肆吹捧了。具有讽刺意味的是，"编写一次，到处运行"并不能完全工作的原因也许是因为多线程系统中的问题而导致的——这在Java SE5中可能已经修复了。
 */
public class Text {
}
