package com.wby.thread.manythread.character21并发.node5线程之间的协作;

/**
 * 正如你所见到的，当你使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会于涉另一个任务的资源。
 * 也就是说，如果两个任务在交替着步入某项共享资源（通常是内存），你可以使用互斥来使得任何时刻只有一个任务可以访问这项资源。
 *
 * 这个问题已经解决了，下一步是学习如何使任务彼此之间可以协作，以使得多个任务可以一起工作去解决某个问题。现在的问题不是彼此之间的干涉，而是彼此之间的协调，因为在这类问题中，某些部分必须在其他部分被解决之前解决。
 * 这非常像项目规划;必须先挖房子的地基。但是接下来可以并行地铺设钢结构和构建水泥部件，而这文两项任务必须在混凝十资注之前完成。管道必须在水泥板浇注之前到位，而水泥板必须在开始构筑房屋骨架之前到位，等等。
 * 在这些任务中，某些可以并行执行，但是某些步骤需要所有的任务都结束之后才能开动。
 *
 * 当任务协作时，关键问题是这些任务之间的握手。为了实现这种握手，我们使用了相同的基础特性;互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号，这样就可以根除任何可能的竞争条件。
 * 在互斥之上，我们为任务添加了一种途径，可以将其自身挂起，直至某些外部条件发生变化（例如，管道现在已经到位），表示是时候让这个任务向前开动了为止。
 * 在本节，我们将浏览任务间的握手问题，这种握手可以通过Object的方法wait（和notifyO来安全地实现。Java SE5的并发类库还提供了具有await（）和signalO方法的Condition对象。我们将看到产生的各类问题，以及相应的解决方案。
 */
public class Text {
}
