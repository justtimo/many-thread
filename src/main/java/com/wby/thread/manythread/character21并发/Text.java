package com.wby.thread.manythread.character21并发;

/**
 * 到目前为止，你学到的都是有关顺序编程的知识。即程序中的所有事物在任意时刻都只能执行一个步骤。
 *
 * 编程问题中相当大的一部分都可以通过使用顺序编程来解决。然而，对于某些问题，如果能够并行地执行程序中的多个部分，则会变得非常方便甚至非常必要，因为这些部分要么看起来在并发地执行，要么在多处理器环境下可以同时执行。
 *
 * 并行编程可以使程序执行速度得到极大提高，或者为设计某些类型的程序提供更易用的模型，或者两者皆有。但是，熟练掌握并发编程理论和技术，对干到目前为止你在本书中学习到的所有知识而言，是一种飞跃，并且是通向高级主题的中介。
 * 本章只能作为一个介绍，即便融会贯通了本章的内容，也绝不意味着你就是一个优秀的并发程序员了。
 *
 * 正如你应该看到的，当并行执行的任务彼此开始产生互相干涉时，实际的并发问题就会接踵而至。这可能会以一种微妙而偶然的方式发生，我们可以很公正地说，并发"具有可论证的确定性，但是实际上具有不可确定性"。
 * 这就是说，你可以得出结论，通过仔细设计和代码审查，编写能够正确工作的并发程序是可能的。但是，在实际情况中，更容易发生的情况是所编写的并发程序在给定适当条件的时候，将会工作失败。
 * 这些条件可能从来都不会实际发生，或者发生得不是很频繁，以至于在测试过程中不会碰上它们。实际上，你可能无法编写出能够针对你的并发程序生成故障条件的测试代码。
 * 所产生的故障经常是偶尔发生的，并且经常是以客户抱怨的形式出现的。这是研究并发问题的最强理由∶如果视而不见，你就会遭其反噬。
 *
 * 因此，并发看起来充满了危险，如果你对它有些畏惧，这可能是件好事。尽管Java SE5在并发方面做出了显著的改进，但是仍旧没有像编译期验证或检查型异常这样的安全网，在你犯错误的时候告知你。
 * 使用并发时，你得自食其力，并且，只有变得多疑而自信，才能用Java编写出可靠的多线程代码。
 *
 * 有时人们会认为并发对于介绍语言的书来说太高级了，因此不适合放在其中。他们认为并发是个独立主题，可以单独来处理，并目对于少数出现在日常的程序设计中的情况 （例如图形化用户界面），可以用特殊的惯用法来处理。
 * 如果你可以回避，为什么还要介绍这么复杂的主题呢?
 *
 * 唉，如果是这样就好了。遗憾的是，你无法选择何时在你的Java程序中出现线程。仅仅是你自己没有启动线程并不代表你就可以回避编写使用线程的代码。
 * 例如，Web系统是最常见的 Java应用系统之一，而基本的Web库类、Servlet具有天生的多线程性———这很重要，因为Web服务器经常包含多个处理器，而并发是充分利用这些处理器的理想方式。
 * 即便是像Servlet这样看起来很简单的情况，你也必须理解并发问题，从而能正确地使用它们。图形化用户界面也是类似的情况，你将在第22章中看到。
 * 尽管Swing和SWT类库都拥有针对线程安全的机制，但是不理解并发，就很难了解如何正确地使用它们。
 *
 * Java是一种多线程语言，并且提出了并发问题，不管你是否意识到了。因此，有很多使用中的Java程序，要么只是偶尔工作，要么在大多数时间里工作，并且会由于未发现的并发缺陷而时不时地神秘崩溃。
 * 有时这种崩溃是温和的，但有时却意味着重要数据的丢失，并且如果没有意识到并发问题，你可能最终会认为问题出在其他什么地方，而不在你的软件中。如果程序被迁移到多处理器系统中，这些种类的问题还会被暴露或放大。
 * 基本上，了解并发可以使你意识到明显正确的程序可能会展示出不正确的行为。
 *
 * 学习并发编程就像进入了一个全新的领域，有点类似于学习一门新的编程语言，或者至少是学习一整套新的语言概念。要理解并发编程，其难度与理解面向对象编程差不多。
 * 如果你花点儿工夫，就能明白其基本机制，但要想真正地掌握它的实质，就需要深入的学习和理解。本章的目标就是要让读者对并发的基本知识打下坚实的基础，从而能够理解其概念并编写出合理的多线程程序。
 * 注意，你可能很容易就会变得过分自信，在你编写任何复杂程序之前，应该学习一下专门讨论这个主题的书籍。
 */
public class Text {
}
