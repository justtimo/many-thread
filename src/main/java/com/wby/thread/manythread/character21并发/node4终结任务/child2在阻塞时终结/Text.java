package com.wby.thread.manythread.character21并发.node4终结任务.child2在阻塞时终结;

/**
 * 前面示例中的Entrance。runO在其循环中包含对sleepO的调用。我们知道，sleepO最终将唤醒，而任务也将返回循环的开始部分，去检查canceled标志，从而决定是否跳出循环。
 * 但是， sleepO一种情况，它使任务从执行状态变为被阻塞状态，而有时你必须终止被阻塞的任务。
 *
 * 线程状态
 * 一个线程可以处于以下四种状态之一∶
 *      1）新建 （new）;当线程被创建时，它只会短暂地处干这种状态。此时它已经分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获得CPU时间了，之后调度器将把这个线程转变为可运行状态或阻塞状态。
 *      2）就绪 （Runnable）;在这种状态下，只要调度器把时间片分配给线程，线程就可以运行也就是说，在任意时刻，线程可以运行也可以不运行。只要调度器能分配时间片给线程，它就可以运行;这不同于死亡和阻塞状态。
 *      3）阻塞（Blocked）∶线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何CPU时间。直到线程重新进入了就绪状态，它才有可[1183
 *          能执行操作。
 *      4）死亡（Dead）;处干死亡或终止状态的线程将不再是可调度的，并且再也不会得到CPU时间，它的任务已结束，或不再是可运行的。任务死亡的通常方式是从runO方法返回，但是任务的线程还可以被中断，你将要看到这一点。
 *
 * 进入阻塞状态
 * 一个任务进入阻塞状态，可能有如下原因∶
 *      1）通过调用sleep（milliseconds）使任务进入休眠状态，在这种情况下，任务在指定的时间内不会运行。
 *      2）你通过调用wait（）使线程挂起。直到线程得到了notify（）或notifyAllO消息（或者在Java SE5的java.util.concurrent类库中等价的signalO）或signalAllO消息），线程才会进入就绪状态。我们将在稍后的小节中验证这一点。
 *      3）任务在等待某个输入/输出完成。
 *      4） 任务试图在某个对象上调用其同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁。
 *
 * 在较早的代码中，也可能会看到用suspendO和resume（来阻塞和唤醒线程，但是在现代Java中这些方法被废止了（因为可能导致死锁），所以本书不讨论这些内容。
 * stopO0方法也已经被废止了，因为它不释放线程获得的锁，并且如果线程处干不一致的状态（受损状态），其他任务可以在这种状态下浏览并修改它们。这样所产生的问题是微妙而难以被发现的。
 *
 * 现在我们需要查看的问题是;有时你希望能够终 止处于阻塞状态的任务。如果对于处于阻塞状态的任务，你不能等待其到达代码中可以检查其状态值的某一点，因而决定让它主动地终止，那么你就必须强制这个任务跳出阻塞状态。
 */
public class Text {
}
