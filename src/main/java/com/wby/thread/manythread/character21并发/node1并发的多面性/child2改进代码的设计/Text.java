package com.wby.thread.manythread.character21并发.node1并发的多面性.child2改进代码的设计;

/**
 * 在单CPU机器上使用多任务的程序在任意时刻仍旧只在执行一项工作，因此从理论上讲，肯定可以不用任何任务而编写出相同的程序。
 * 但是，并发提供了一个重要的组织结构上的好处∶你的程序设计可以极大地简化。某些类型的问题，例如仿真，没有并发的支持是很难解决的。
 *
 * 大多数人都看到过至少一种形式的仿真，例如计算机游戏或电影中计算机生成的动画。仿真通常涉及许多交互式元素，每一个都有"其自己的想法"。尽管你可能注意到了这一点，但是在单处理器机器上，
 * 每个仿真元素都是由这个处理器驱动执行的，从编程的角度看，模拟每个 1114仿真元素都有其自己的处理器并且都是独立的任务，这种方式要容易得多。
 *
 * 完整的仿真可能涉及非常大量的任务，这与仿真中的每个元素都可以独立动作这一事实相对应———这其中包含门和岩石，而不仅仅只是精灵和巫师。多线程系统对可用的线程数量的限制通常都会是一个相对较小的数字，
 * 有时就是数十或数百这样的数量级。这个数字在程序控制范围之外可能会发生变化——它可能依赖于平台，或者在Java中，依赖于Java的版本。在Java中，通常要假定你不会获得足够的线程，从而使得可以为大型仿真中的每个元素都提供一个线程。
 *
 * 解决这个问题的典型方式是使用协作多线程。Java的线程机制是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另一个线程，从而为每个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动它的任务。
 * 在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识地在每个任务中插入某种类型的让步语句。协作式系统的优势是双重的; 上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。
 * 当你处理大量的仿真元素时，这可以一种理想的解决方案。但是注意，某些协作式系统并未设计为可以在多个处理器之间分布任务，这可能会非常受限。
 *
 * 在另一个极端，当你用流行的消息系统工作时，由于消息系统涉及分布在整个网络中的多台独立的计算机，因此并发就会成为一种非常有用的模型，因为它是实际发生的模型。
 * 在这种情形中，所有的进程都彼此完全独立地运行，甚至没有任何可能去共享资源。但是，你仍旧必须在进程间同步信息，使得整个消息系统不会丢失信息或在错误的时刻混进信息。
 * 即使你没有打算在眼前大量使用并发，理解并发也会很有用，因为你可以掌握基于消息机制的架构，这些架构在创建分布式系统时是更主要的方式。
 *
 * 并发需要付出代价，包含复杂性代价，但是这些代价与在程序设计、资源负载均衡以及用户方便使用方面的改进相比，就显得微不足道了。
 * 通常，线程使你能够创建更加松散耦合的设计，否则，你的代码中各个部分都必须显式地关注那些通常可以由线程来处理的任务。
 */
public class Text {
}
