package com.wby.thread.manythread.Chaptor16数组.node8总结;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/7/19 11:03
 * @Description:    本章中，看到了java对尺寸固定的低级数组提供了适度的支持。这种数组强调的是性能而不是灵活性，并且与C和C++的数组模型类似。在java
 * 的初始版本中，尺寸固定的低级数组绝对是必须的，不仅是因为java的设计者选择在java中要包含基本类型(也是出于性能方面的考虑)，而且还因为那个版本中对容器的
 * 支持非常少。因此，在java早期版本中，选择包含数组总是合理的。
 *
 * 其后的java版本对容器的支持得到了明显的改进，并且现在的容器在除了性能之外的各个方面都使得数组相形见绌。
 * 就像本书其他多处地方所叙述的那样，对你来说，性能出问题的地方通常是无论如何你都无法想象的到的。
 *
 *  有了额外的自动包装机制和泛型，在容器中持有基本类型就变得易如反掌了，而这也进一步促使你用容器来替换数组。因为泛型可以产生类型安全的容器，因此数组面
 *  对这一变化，已经变得毫无优势了。
 *
 *  当你尝试着使用他们时也会看到，泛型对数组是极大的威胁。通常，即使当你可以让泛型与数组以某种方式一起工作时，编译期你最终也会得到“不受检查”的警告信息。
 *
 *  一切都表示：当你使用最近的java版本编程时，应该优先选择容器而不是数组。
 *  只有在已证明性能成为问题(且切换到数组对性能提高有所帮助)时，你才应该将程序重构为使用数组。
 *
 *  但是有些语言没有尺寸固定的低级数组，他们只有尺寸可调的容器，这些容器与c/c++/java风格的数组相比，明显具有更多的功能。
 *  例如，Python具有一个使用基本数组语法的List类型，但是他具有更多功能----你甚至可以继承他。
 *          aLsit=[1,2,3,4,5]
 *          print( type(aLsit))
 *          print(aLsit)
 *          print(aLsit[4])
 *
 *          aLsit.append(6)
 *
 *          aLsit+=[7,8]
 *          print(aLsit)
 *          aSlice=aLsit[2:4]
 *          print(aSlice)
 *
 *          class MyList(list):
 *          	def getReversed(self):
 *          		reversed=self[:]
 *          		reversed.reverse()
 *          		return reversed
 *
 *          list2=MyList(aLsit)
 *          print(type(list2))
 *          print(list2.getReversed())
 */
/**
* @Description: 上例中，直接通过用方括号括起来的且由逗号分割的对象序列，创建了一个列表，所产生的过节就是运行时类型为List的一个对象(print语句的
 * 输出如一行的注释所示)。打印List的结果与使用java中的Arrays.toString()相同。
 *
 * 创建List的子序列是通过在索引操作的内部放置“：”操作符，从而用“切片”来实现的。List类型具有很多内置的操作。
 *
 * MyList是一个类定义，在括号内的是其基类。在这个类的内部，def将产生方法，而方法的第一个参数自动的与java中的this等价，只是在Python中他是显示的，
 * 并且按惯例其标识符为self(这不是关键字)。请注意构造器时如何自动继承的。
 *
 * 尽管Python中的每项事物确实都是对象(包括整型和浮点类型)，但是仍旧有其他出口，使得你可以去优化代码中性能关键的部分，这是需要用c或c++编写一些扩展，
 * 或者使用被称为Pyrex的特殊工具，他被设计用来让我们更方便的提高代码的执行速度。通过这种方式，你仍旧可以保持对象的纯粹性，同时又不妨碍对性能的改进。
 *
 * java不断演化了许多年后，研究这样一个问题会相当有趣：如果java的设计者们能够从头再来，他们是否还会在java语言中设计基本类型的低级数组。如果当初抛弃
 * 他们，java也许就会成为真正的纯面向对象语言(java不是纯面向对象语言，原因正是这些低级的绊脚石)。最初有关效率的论点总是很吸引人，随着时间推移，我们看到了
 * 于这种思想背道而驰，向着使用像容器这类高级构件的方向的演化。
 * 另外，如果容器能够像某些语言一样内置于语言的内核中，那么编译器就会得到更好地优化良机
 *
 * 我们肯定还会使用数组，并且在读代码的时候还会看到他，但是，容器几乎总是更好地选择。
*/
public class Text {
}
