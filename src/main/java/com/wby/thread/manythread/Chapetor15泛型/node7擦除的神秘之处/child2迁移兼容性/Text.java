package com.wby.thread.manythread.Chapetor15泛型.node7擦除的神秘之处.child2迁移兼容性;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/7/12 10:31
 * @Description:    为了减少潜在的关于擦除的混淆，你必须知道这不是一个语言特性。他是java泛型实现中的一种折中，因为泛型不是java出现时就有的一部分
 *  ，所以这种这种是必需的。这种这种会使你痛苦，因此你不需要知道为什么他是这样的。
 *
 *  如果java在1。0中就已经有了，呢么这个特性将不会使用擦除来实现---他将使用 具体化 ，使类型参数保持为第一类实体，因此你就能在类型参数上执行基于类型的
 *  语言操作和反射操作。稍后你将看到，擦除减少了泛型的泛化性。泛型在java中仍旧是有用的，知识不如他们本来设想的那么有用，原因就是擦除。
 *
 *  在基于擦除的实现中，泛型类型被当做第二类类型处理，即不能再某些重要的上下文环境中使用的类型。
 *  泛型类型只有在静态类型检查掐尖才出现，之后，程序中所有泛型类型都将被擦除，替换为他们的非泛型上届。例如，诸如List<T>这样的类型注解将被擦除为List，而
 *  普通的类型变量在未指定边界的情况下将被擦除为Object。
 *
 *  擦出的核心动机是他使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被称为“迁移兼容性”。理想情况下，当所有的事物都可以同时被泛华时，我们就可以专注于此。
 *  现实中，即使程序员只编写泛型代码，他们也必须处理在1.5之前编写的非泛型类库。那些类库的作者可能没想过要泛化他们的代码，或者可能刚刚开始接触泛型。
 *
 *  因此java泛型不仅必须支持向后兼容：即现有代码与类文件仍旧合法，并且继续保持之前的含义；还要支持迁移兼容性，使得类库按照他们自己的步调变为泛型的，并
 *  且当某个类库变为泛型时，不会破换依赖于他的代码和应用程序。在决定这就是目标之后，java设计者和从事此问题的各个团队认为擦除是唯一可行的解决方案。通过
 *  允许非泛型代码与泛型代码共存，擦除使得这种向着泛型的迁移成为可能。
 *
 *  例如，某个应用具有两个类库X和Y，并且Y还要使用类库Z。随着1.5出现，这个程序和类库最终可能希望迁移到泛型上。但是，当进行迁移时，他们有着不同动机和限制。
 *  为了实现迁移兼容性，每个类库和程序都必须和其他所有的部分是否使用了泛型无关。这样，他们必须不具备探测其他类库是否使用了泛型的能力。因此，某个特定的
 *  类库使用了泛型这样的证据必须被“擦除”
 *
 *  如果没有某种类型的迁移途径，所有已经构建了很馋时间的类库就需要与迁移到java泛型上的开发者们说再见。但是，类库是编程语言无可争议的一部分，他们对生产
 *  效率会产生最重要的影响，因此这不是一种可以接受的代价。擦除是否是最佳的或者唯一的迁移途径，还需要时间证明。
 */
public class Text {
}
