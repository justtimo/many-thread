package com.wby.thread.manythread.Chapetor15泛型;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/7/9 09:51
 * @Description:    一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，
 * 这种刻板的限制对代码产生的束缚就会很大。
 *
 *  面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数设为基类，那么该方法就可以接受从基类中导出的任何类作为参数。
 *  这样方法更加通用。在类的内部也是如此，凡是需要说明类型的地方，如果都使用基类，确实能够具备更好地灵活性。
 *  但是，考虑到除了final类(或者具有private构造起的类)不能扩展，其他任何类都可以扩展，所以这种灵活性大多数时候也会有性能损耗。
 *
 *  有时，拘泥于单继承也会使程序受限太多，
 *  如果方法参数是一个接口，而不是一个类，这种限制就放松了许多。因为任何实现了该接口的类都能够满足该方法，这也包括暂时还不存在的类。
 *  这就给程序员提供了一种选择，可以通过实现一个接口来满足类或方法。因此，接口允许我们快捷的实现类继承，也是我们有机会创建一个新类做到这一点
 *
 *  可有时候，即便使用接口对程序的约束还是太强了。因为一旦指明接口，你就要求你的代码必须使用特定的接口。
 *  我们希望达到的目的是编写更加通用的代码，使之能够用于“某种不具体的类型”，而不是一个具体的接口或类。
 *
 *  这就是1.5重要的变化一直：泛型。
 *  泛型实现了 参数化类型 的概念，使代码可以应用多种类型。泛型的意思是：“适用于许多的类型”。
 *  泛型在编程语言中出现时，最初的目的是希望类或方法能够具备最广泛的表达能力。通过解耦类或方法与所使用的类型之间的约束。
 *  稍后将会看到，java中的泛型并没有这么高的追求，你还可能会质疑，java中术语“泛型”是否适合用来描述这一功能。
 *
 *  如果你从未接触过参数化类型机制，那么学习了java泛型后，你会发现，泛型确实是一个有益的补充：创建参数化类型的实例时，编译器会为你负责转型操作，并保证类型
 *  的正确性。
 *  但如果你了解其他语言中的参数化类型机制，你会发现，有些以前能做到的事情，使用java泛型缺无法做到。
 *
 *  本章中，作用之一就是解释，java中的泛型是怎么发展成现在这样的。
 *  我们会介绍java泛型的优点与局限，希望这能帮你更有效的使用java这个新功能
 */
public class Text {
}
