package com.wby.thread.manythread.Chapetor15泛型.node19总结转型真的如此糟糕吗;

/**
 * @Auther: LangWeiXian
 * @Date: 2021/7/16 13:53
 * @Description:    使用泛型类型机制的最吸引人的地方，就是在使用容器类的地方，这些类包括诸如各种List、Set、Map等和17章看到的各种了类。1.5之前，
 * 当你将一个对象放置到容器中时，这个对象就会被向上转型为Object，因此你会丢失类型信息。
 * 当你向将这个对象从容器中取回时，用它执行某些操作时，必须将其向下转型为正确的类型。我用的例子是持有Cat的List。
 * 如果没有1.5泛型版本的容器，你放在容器里和从容器中取出的，都是Object。因此，很可能会将DOg放置到Cat的List中。
 *
 * 但是，泛型出现之前的java并不会让你无用放入到容器中的对象。
 * 如果将一个DOg放在Car容器中，并将容器中的所有东西都当做Cat处理，当你从这个cat容器中取回那个DOg引用，并试图转型为Cat时，就会得到RUntimeException
 * 你可以发现问题，但是是在运行时而非编译期。
 *
 * 在21章中会看到，在使用线程时，会出现看起来极其罕见的缺陷。因此，对于泛型是添加到java中的非常显著和复杂的特性这一点。狗在猫列表中 这个真的能够成为理由吗？
 *
 * 被称为泛型的通用语言特性的目的在于可表达性，而不仅仅是为了创建类型安全的容器。类型安全的容器是能够创建更通用的代码这一能力所带来的副作用。
 *
 * 因此，即便狗在猫列表 这个论据正经常被用来证明泛型是必要的，打他仍旧是有问题的。我不相信这就是泛型这个概念真正的含义，相反，泛型正如其名称所暗示的：
 *  它是一种方法，通过他可以编写出更“泛化的”代码，这些代码对于他们能够作用的类型具有更少的限制，因此单个的代码段可以应用到更多的类型上。
 *  正如本章中看到的，编写真正泛化的“持有器”类(java容器就是这种类)相当简单，但是编写出能够操作其泛型类型的泛化代码就需要额外的努力，这些努力需要类
 *  创建者和类消费者共同付出，他们必须理解适配器设计模式的概念和实现。
 *  这些努力会增加使用这种特性的难度，并可能会因此而使其在某些场合缺乏可应用性，二组这些长河中，他可能会带来附加的价值。
 *
 *  需要注意到，因为泛型时后来添加到java中的，所以某些容器无法达到他们应该具有的健壮性、
 *  例如Map，在特定的方法containsKey(key)和get(key)中就包含这种情况。
 *  如果这些类是在他们之前就存在泛型设计的，那么这些方法将会使用参数化类型而不是Object，因此也就可以提供这些泛型假设会提供的编译期检查。例如，C++的mao，键的类型总是编译期检查的
 *
 *  很明显：当广泛应用后，在新版本中引入任何种类的泛型机制，都会是非常棘手的任务。
 *  java中，泛型是在首次发布大约10年后才引入的，因此向泛型迁移的问题很多。
 */
public class Text {
}
